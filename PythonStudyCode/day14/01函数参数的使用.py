# @time: 2021/12/10 11:22 上午
# Author: pan
# @File: 01函数参数的使用.py
# @Software: PyCharm

"""
# 形参实参：
# 在函数定义的时候定义的参数称为形式参数简称形参 相当于变量名
# 在函数调用的时候传入的值称为实际参数 简称实参 相当于是变量的值
# 1、在调用函数的时候，实际参数会绑定给形式参数
# 2、这种绑定关系只会在函数体内部使用
# 3、形式参数和实际参数的绑定发生在调用函数的时候，函数调用结束之后解除绑定关系

PS: 引用传递
 Python中所有值的传递，传递的不是值的本身
 而是值的引用也就是值的内存地址
 函数参数的传递也是引用传递

函数分为两大类：
1、内置函数 （Python解释器中已经存在的函数）
2、用户定义函数

形式参数的类型有：
1、位置参数
2、关键字参数 实参
3、默认参数
4、可变长度位置参数 *args
5、可变长度关键字参数 **kwargs
"""


"""
1、位置参数
从左到右依次定义的参数称之为位置参数或使用*args声明的参数
位置参数必须被传入值 多一个少一个都不行
必须为每一个位置参数传递值, 而且顺序必须一一对应
"""
def func(x, y):
    print(x, y)

# TypeError: func() takes 2 positional arguments but 3 were given
# 报错 需要两个位置参数 但是给了三个
# func(10, 10, 30)

# TypeError: func() missing 1 required positional argument: 'y'
#  报错 缺少一个位置参数y
# func(10)

# 位置参数的传值 如果没有使用关键字实参进行传递 需要一一对应
# 如果使用的关键字实参进行传递 位置可以交换
# func(1, 2)
# func(x=10, y=20)
# func(y=100, x=300)

# 2、关键字实际参数
# 根据参数的名称进行传值，可以不依据位置参数的顺序
# 按照 key = value的形式 进行传入值
# func(y = 20, x = 100)

# 位置参数的传值 必须放到关键字参数的前面
# error
# func(x = 100, 200)
# success
# func(100, y = 200)
# 不能为一个值传入多个实参
# func(100, x = 200, y = 300)
# func(100, x = 300)


"""
3、默认参数
# 在定义函数的时候直接给位置参数一个默认值
# 如果调用函数的时候没有传值那么使用默认的值
# 如果调用函数的时候有传入值那么使用传入的实参数的值
# 默认参数的定义 必须放到 位置参数的后面
"""
# 错误 默认参数放在了位置参数的前面
# def regiser(name = "pan", age, sex):
#     print(name, age, sex)
# 正确
def regiser(name, age, sex="男"):
    print(name, age, sex)

# regiser("pan", 20)
# regiser("zhao", 18)
# regiser("mary", 20, "女")


"""
默认参数设置为可变还是不可变?
# 默认参数的值最好是提供一个不可变的值
# 参数实际上是放的是变量的内存地址
# 虽然参数可以是任意类型的数据 但是不建议使用可变数据类型
# PS: 函数最好的状态是：函数的调用只与函数本身有关，不受外界代码的影响
"""
# # 1、使用不可变数据定义参数
# m = 2
# def add(x, y = m):
#     # y 默认存放的是值2的内存地址 而不是m
#     print(x, y)
# # 在函数定义之后 修改m的值 不会影响add函数的默认参数的值
# m = 100
# add(1)  # 1, 2
# m = 1000
# add(1, 20)  # 1, 20

# # 2、使用可变参数定义函数参数的默认值
# m = [1111,]
# def add(x, y = m):
#     # y 默认存放的是列表的内存地址 列表是可变的
#     print(x, y)
# # 这里对列表中的内容进行修改 对应函数的默认参数也会跟着变化
# m.append("22222")
# m.append("333")
# add(1)
# # 这里再将m赋值给一个不可变的值 不会影响y的默认参数
# m = 666
# add(1)
# # 直接在传递参数的时候给y传递一个参数 这时不会使用函数的默认参数m了
# add(1, 20)


"""
4、可变位置参数 *args
# *形参名 ：用来接受溢出的位置参数
# 溢出的位置参数会被*保存为 - 元组 - 的格式 然后赋值紧跟其后的形参名
# *后面可以跟任何自定义的参数名， 但是约定俗成的使用args
# 函数传递的实参可以是其他任意类型的可迭代类型 
# 在传递的实参的时候 会首先将参数打散成位置实参 然后再传入到函数中
"""
def func1(x, y, z, *args):
    print(x, y, z, args)

# (40, 50, 60) 会被自动转换为元组的形式 并赋值给args
func1(10, 20, 30, 40, 50, 60)
# 传参数的时候对于不确定个数的类型 可以使用*进行定义
# *后面可以跟多种类型的可迭代类型
# 传递的参数 会先将*后面的数据 先打散成位置参数 然后再赋值给对应的形参
# 100 20 90 ('h', 'e', 'l', 'l', 'o')
func1(100, 20, 90, *"hello")
# 1 2 3 (4, 5, 10)
func1(*[1, 2, 3, 4, 5, 10])
# 对于如果是字典 打散的是key  而不是value
# 10 k1 k2 ('k3', 'k4', 'k5')
func1(10, *{"k1": 111, "k2": 2222, "k3": 333, "k4": 44, "k5": 30})


# 实例：
# 获取任何数量的和
# def get_sum(*args):
#     sum = 0
#     for item in args:
#         sum += item
#     print(sum)
#     return sum
#
# get_sum(10, 20, 3, 3, 2, 23, 11, 99, 10)
# += 限制了只能传入int类型的数据
# get_sum(10, 20, 3, 3, 2, 23, 11, 99, "10")
# get_sum("10", "20", "30")


"""
5、可变关键字参数 **kwargs
# **参数名： 用于接收多余的关键字参数
# **会将溢出的关键字参数保存为字典形式 key：value 并将其赋值给后面的参数名
# **后面的参数名 同理可以是任何自定义参数名， 但是约定俗成的使用kwargs
可变关键字参数只能传入key = value形式的实参
"""
def func2(x, **kwargs):
    print(x, kwargs)

# error 最多只能传入一个位置参数
# func2(10, 20, 30)
# 可以都是关键字参数 但是必须有一个x的关键字参数
# 因为第一个位置参数对应着x
# 10 {'y': 20, 'z': 30}
func2(y=20, z=30, x=10)
# 如果没有提供x对应的实参值  位置参数必须提供实参数
# func2(y = 100, z = 200)
# 10 {'y': 10, 'z': 20, 'k': 100}
func2(10, y=10, z=20, k=100)
# 只传入一个参数 那么kwargs是一个空字典
# 10 {}
# func2(10)
# 位置参数只能对应一个实参   10默认是对应位置参数x 又传入一个关键字参数x = 20
# 那么就相当于传入了两个x的实参数 会报错
# func2(10, x = 20)

# 实参数使用 **  但是后面跟的只能是字典
# 会先将**后面的字典进行打散成关键字参数 然后在传递给对应形参
func2(10, **{"10": "10", "20": "20", "30": "30"})
