"""
垃圾回收机制  （了解）
如果一个值的引用计数为0  也就是没有任何变量引用着该值
那么这个值就会被自动回收
"""

# x = 10
# z = y = x
# print(id(x), id(y), id(z))
# y = 100 # 变量y重新指向了另一个值的内存地址
# print(id(x), id(y), id(z))
# del y
# print(y)

# x = 10
# l = ["1", "zhaopan", x]
# print(id(x), id(l[2]))
# l变量指向一个内存地址
# 列表中存放的是值对应的内存地址
# 该地址是存放在栈空间的 值是存放在堆内存中
# print(id(l), id(l[0]))

# x = 100
# 将x重新指向一个新值100 对应的内存地址

# l中的第三个元素 指向的还是10 所对应的内存地址 一直没有改变
# print(x, l)


# x = 10
# l = ["a", "b", 10]
# print(id(x), id(l[2]))
# 4310965264 4310965264
# x指向的内存地址 是10所对应的内存地址
# l[2] 所保存的也是10所对应的内存地址
# 所以两个对应的id是一致的


# 标记清除: 用于解决循环引用所造成的内存泄漏问题
# Python使用的是分代回收 用于降低引用计数的扫描频率
# 提升垃圾回收的效率
# list1 = [1111, ]
# list2 = [222, ]
#
# list1.append(list2)
# list2.append(list1)
# print(list1, list2)
#
# del list1
# del list2
#
# print(list2)
# list1和list2相互append所以 造成了相互引用
# 如果删除list1  因为list2有引用list1对应的值 所以list1对应的值不会被回收
# 删除list2 因为list1有引用list2对应的值 所以list2所对应的值也不会被回收
# 所以就造成了 在内存中有两个值 没有任何变量引用 这两个值

# Python会使用 分代回收的方式， 将内存中的垃圾值 进行清除掉（类似清洁工）
# 修改
